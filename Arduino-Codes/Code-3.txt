// --------------------------------------------------------------------------------------- //
// Robert's Smorgasbord 2023                                                               //
// https://robertssmorgasbord.net                                                          //
// https://www.youtube.com/@robertssmorgasbord                                             //
// Capacitive Liquid Level Sensing (6): Analog to Digital (3) https://youtu.be/g8fjN2WKGN4 //
// --------------------------------------------------------------------------------------- //

// #define DEBUG // Debugging-Option: Wenn aktiviert, wird mehr Debug-Information in der seriellen Ausgabe angezeigt.

// Definieren der Pin-Nummern für den Sensor und das Steuersignal
const byte sense_pin = 21;         // Pin, an dem der Kapazitätssensor angeschlossen ist (analoger Eingang)
const byte drive_pin = 20;         // Pin, der das Steuersignal für den Sensor liefert (digitaler Ausgang)

// Definieren der Parameter für den Lade- und Entladeprozess
const unsigned long charge_time_us = 250;   // Ladezeit des Sensors in Mikrosekunden (µs)
const unsigned long discharge_time_ms = 50;  // Entladezeit des Sensors in Millisekunden (ms)
const float resistor_value_mohm = 5.1;      // Widerstandswert für den RC-Kreis in Megaohm (MΩ)
const unsigned int average_n_measurements = 10;  // Anzahl der Messungen, die gemittelt werden

// Konvertierungsfaktoren für die Umrechnung von Kapazität in Volumen (ml)
const float conversion_factor = 11.5;  // Umrechnungsfaktor von Kapazität (pF) in Volumen (ml)
const float conversion_offset = -569.0; // Offset-Wert für die Volumenberechnung (ml)

// Setup-Funktion wird einmal beim Starten des Programms ausgeführt
void setup() {
   Serial.begin(1000000L); // Initialisiere die serielle Kommunikation mit einer Baudrate von 1.000.000

   while (!Serial);  // Warten, bis die serielle Kommunikation vollständig initialisiert ist

   pinMode(drive_pin, OUTPUT);  // Setze den Steuersignal-Pin als Ausgang
   digitalWrite(drive_pin, LOW); // Setze das Steuersignal zu Beginn auf LOW (Signal aus)
}

// loop() wird kontinuierlich in einer Schleife ausgeführt
void loop() {
   float capacitance_pf;         // Variable zur Speicherung der gemessenen Kapazität in Pikofarad (pF)
   unsigned int measurement;     // Zähler für die Anzahl der Messungen

   capacitance_pf = 0;           // Setze die Kapazität zu Beginn auf 0

   // Sammle mehrere Messungen und berechne den Durchschnitt
   for (measurement = 0; measurement < average_n_measurements; measurement++) {
      capacitance_pf = capacitance_pf + measure_capacitance_pf(); // Addiere die gemessene Kapazität
   }

   capacitance_pf = capacitance_pf / average_n_measurements; // Berechne den Durchschnitt der Messungen

   // Gib die gemessene Kapazität und das berechnete Volumen aus
   Serial.print(capacitance_pf, 1);           // Gebe die Kapazität in pF aus
   Serial.print("pF | ");                     // Beschriftung für pF
   Serial.print(capacitance_pf * conversion_factor + conversion_offset, 1); // Berechne und gebe das Volumen in ml aus
   Serial.print("ml");
   
   Serial.println("");  // Neue Zeile für die nächste Ausgabe
   delay(1);            // Kurze Verzögerung von 1 ms
}

// Funktion zur Messung der Kapazität des Sensors in Pikofarad (pF)
float measure_capacitance_pf() {
   unsigned int adc_value_discharged; // ADC-Wert nach Entladen des Sensors
   unsigned int adc_value_charged;    // ADC-Wert nach Laden des Sensors
   
   digitalWrite(drive_pin, LOW);    // Setze den Steuersignal-Pin auf LOW, um den Sensor zu entladen
   delay(discharge_time_ms);        // Warte für die Entladezeit (in Millisekunden)
   
   adc_value_discharged = analogRead(sense_pin);  // Lese den Entladewert des Sensors mit analogRead()

   // Fehlerbehandlung: Wenn der Entladewert zu hoch ist, gibt es einen Fehler
   if (adc_value_discharged > 1023 * 0.1) 
      Serial.println("ERROR: Discharged voltage too high!");  

   digitalWrite(drive_pin, HIGH);  // Setze das Steuersignal auf HIGH, um den Sensor zu laden
   delayMicroseconds(charge_time_us);  // Warte für die Ladezeit (in Mikrosekunden)

   adc_value_charged = analogRead(sense_pin);  // Lese den Ladewert des Sensors

   digitalWrite(drive_pin, LOW);  // Setze das Steuersignal wieder auf LOW, um den Sensor zu entladen
   
   // Fehlerbehandlung: Wenn der Ladewert zu hoch oder zu niedrig ist, gibt es einen Fehler
   if (adc_value_charged > 1023 * 0.9) 
      Serial.println("ERROR: Charged voltage too high!");
   if (adc_value_charged < 1023 * 0.2) 
      Serial.println("ERROR: Charged voltage too low!");

   // Optional: Debugging-Ausgabe für die gemessenen ADC-Werte
   #ifdef DEBUG
      Serial.print(adc_value_discharged); // Gebe den Entladewert aus
      Serial.print(" | ");
      Serial.print(adc_value_charged);    // Gebe den Ladewert aus
      Serial.print(" | ");
   #endif
     
   // Berechne und gebe die Kapazität des Sensors in pF zurück
   return capacitance_pf(resistor_value_mohm,  // Widerstandswert des RC-Elements
                         5.0 * (1023 - adc_value_discharged) / 1024.0, // Berechne die Spannung beim Entladen
                         charge_time_us,  // Ladezeit in Mikrosekunden
                         5.0 * (adc_value_charged - adc_value_discharged) / 1024.0); // Berechne die Spannung beim Laden
}

// Funktion zur Berechnung der Kapazität eines Sensors basierend auf den Messwerten
float capacitance_pf(float r_mohm,  // Widerstand in MOhm
                     float vb_v,    // Lade-Spannung in Volt
                     float t_us,    // Ladezeit in Mikrosekunden
                     float vc_t_v ) // Spannung am Kondensator nach der Ladezeit in Volt                 
{
   // Formel zur Berechnung der Kapazität eines Sensors aus dem RC-Kreis
   // C = - (t / R) / ln(1 - (Vc(t) / Vb))

   return -1.0 * ((t_us / r_mohm) / log(1 - (vc_t_v / vb_v)));  // Berechnete Kapazität in pF zurückgeben
}

/* Erklärungen

Pin-Definitionen:

sense_pin und drive_pin: Diese Pins steuern und messen den Kapazitätswert des Sensors. sense_pin liest den Wert des Sensors, und drive_pin steuert das Lade- und Entladen des Sensors.
Lade- und Entladezeiten:

charge_time_us und discharge_time_ms definieren, wie lange der Sensor geladen und entladen wird. Dies ist wichtig, um eine genaue Messung der Kapazität zu erhalten.
Messung und Berechnung:

In der Funktion measure_capacitance_pf() wird der Sensor zuerst entladen und dann geladen. Der Unterschied zwischen den Entlade- und Ladewerten des Sensors wird verwendet, um die Kapazität zu berechnen.
Fehlerbehandlung:

Es gibt Fehlerprüfungen, um sicherzustellen, dass die Messwerte im erwarteten Bereich liegen. Falls die Spannung zu hoch oder zu niedrig ist, wird eine Fehlermeldung ausgegeben.
Kapazitätsberechnung:

Die Funktion capacitance_pf() berechnet die Kapazität eines Sensors basierend auf den gemessenen Spannungen und der Ladezeit. Die Berechnung basiert auf einer logarithmischen Formel, die aus den Eigenschaften eines RC-Kreises abgeleitet ist. */