// --------------------------------------------------------------------------------------- //
// Robert's Smorgasbord 2023                                                               //
// https://robertssmorgasbord.net                                                          //
// https://www.youtube.com/@robertssmorgasbord                                             //
// Capacitive Liquid Level Sensing (5): Analog to Digital (2) https://youtu.be/BoutyoQyOQI //
// --------------------------------------------------------------------------------------- //

const byte            sense_pin = 21;  // Der Pin, an dem der Sensor angeschlossen ist (z.B. ein Capacitive Sensing Pin)
const byte            drive_pin = 20;  // Der Pin, der für das Aufladen des Sensors verantwortlich ist (z.B. für das Erzeugen eines Signals)

const unsigned int    measurement_period = 500;     // Messzeitraum in Millisekunden, wie lange jede Messung dauert
const unsigned int    threshhold_low     = 256;     // Untere Schwelle für den Messwert, unterhalb dieser Schwelle wird der Sensor als "entladen" betrachtet (~1.25V bei 10-bit ADC)
const unsigned int    threshhold_high    = 767;     // Obere Schwelle für den Messwert, oberhalb dieser Schwelle wird der Sensor als "aufgeladen" betrachtet (~3.75V bei 10-bit ADC)
//const float           conversion_factor  = 1.299;   // Umrechnungsfaktor für die Oszillationsperiode [us] zu Volumen [ml], wurde hier auskommentiert
//const float           conversion_offset  = -27.401; // Offset für das Volumen in [ml], wurde hier auskommentiert

void setup()
{
   Serial.begin(9600L); // 9600 Baudrate für die serielle Kommunikation, um Daten zum Monitor zu senden

   while (!Serial); // Warten, bis die serielle Kommunikation verfügbar ist

   pinMode(sense_pin, INPUT);   // Setzt den Pin für den Sensor auf "Input", um Messwerte zu lesen
   pinMode(drive_pin, OUTPUT);  // Setzt den Pin für die Ansteuerung des Sensors auf "Output", um den Sensor zu steuern
}

void loop()
{
   byte          drive_pin_level;    // Variable, die den Zustand des "drive_pin" speichert (hoch oder niedrig)
   unsigned int  cycles;             // Zähler für die Anzahl der Messzyklen
   unsigned long measurement_finish; // Speichert die Zeit, bis die Messung abgeschlossen ist

   cycles             = 0;                       // Initialisiere den Zähler für die Zyklen auf 0
   drive_pin_level    = LOW;                     // Setze den "drive_pin" zunächst auf LOW (d.h. "aus")
   measurement_finish = millis() + measurement_period;  // Bestimmt die Endzeit für die Messung basierend auf dem Messzeitraum

   digitalWrite(drive_pin, drive_pin_level); // Setze den Zustand des "drive_pin" auf LOW (Sensor wird entladen)

   while (measurement_finish > millis()) // Solange die Messzeit nicht vorbei ist
   {      
      switch (drive_pin_level)  // Überprüft den Zustand des "drive_pin"
      {
         case LOW:  
            if (analogRead(sense_pin) <= threshhold_low)  // Wenn der Sensorwert unterhalb der unteren Schwelle liegt (Sensor "entladen")
            {
               cycles++;  // Zähle einen Zyklus
               drive_pin_level = HIGH;  // Setze den "drive_pin" auf HIGH (Sensor wird geladen)
               digitalWrite(drive_pin, drive_pin_level); // Wende HIGH an, um den Sensor zu laden
            }
            break;

         case HIGH: 
            if (analogRead(sense_pin) >= threshhold_high) // Wenn der Sensorwert oberhalb der oberen Schwelle liegt (Sensor "aufgeladen")
            {
               drive_pin_level = LOW;  // Setze den "drive_pin" zurück auf LOW (Sensor wird entladen)
               digitalWrite(drive_pin, drive_pin_level); // Wende LOW an, um den Sensor zu entladen
            }
            break;
      }
   }

   Serial.print(cycles);  // Zeige die Anzahl der Zyklen an (d.h. wie oft der Sensor geladen und entladen wurde)
   Serial.print("CY | ");
   Serial.print((float)cycles / measurement_period * 1000, 1);  // Berechne die Häufigkeit der Zyklen in Hz (Zyklen pro Sekunde)
   Serial.print("Hz | ");
   Serial.print((float)measurement_period / cycles * 1000, 1);  // Berechne die Dauer eines einzelnen Zyklus in Mikrosekunden (µs)
   Serial.print("us | ");
   //Serial.print(((float)measurement_period / cycles * 1000)
   //             * conversion_factor 
   //             + conversion_offset, 1                              ); // Umrechnung auf Volumen (ml) - Auskommentiert
   //Serial.print("ml");

   Serial.println("");  // Neue Zeile im seriellen Monitor
}

/*  Erklärungen

sense_pin und drive_pin: Diese beiden Variablen definieren, welche Pins des Mikrocontrollers für das Capacitive Sensing und das Steuern des Sensors verwendet werden. sense_pin ist der Eingangspin, an dem der Sensor angeschlossen ist, und drive_pin ist der Ausgangspin, der für das Steuern des Lade- und Entladevorgangs des Sensors verantwortlich ist.

measurement_period: Die Zeit, in der eine Messung stattfindet, wird in Millisekunden angegeben. In diesem Fall wird alle 500 ms eine Messung durchgeführt.

threshhold_low und threshhold_high: Diese Werte definieren die Schwellenwerte für den Sensor. Wenn der Sensorwert unterhalb von threshhold_low liegt, wird er als "entladen" betrachtet, und wenn der Wert oberhalb von threshhold_high liegt, wird er als "aufgeladen" betrachtet. Diese Werte basieren auf den Spannungswerten des Sensors.

digitalWrite(drive_pin, drive_pin_level): Diese Funktion wird verwendet, um den Zustand des drive_pin zu ändern. Sie steuert, ob der Sensor geladen oder entladen wird. Wenn drive_pin_level auf HIGH gesetzt wird, wird der Sensor geladen, und wenn es auf LOW gesetzt wird, wird der Sensor entladen.

analogRead(sense_pin): Diese Funktion liest den Wert des sense_pin (der Sensorwert) und entscheidet anhand dieses Werts, ob der drive_pin auf HIGH oder LOW gesetzt werden muss.

cycles: Diese Variable zählt die Anzahl der Zyklen, in denen der Sensor geladen und entladen wurde. Am Ende jeder Messung wird die Anzahl der Zyklen ausgegeben. */