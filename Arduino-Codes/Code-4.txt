// -------------------------------------------------------------------------------------- //
// Robert's Smorgasbord 2023                                                              //
// https://robertssmorgasbord.net                                                         //
// https://www.youtube.com/@robertssmorgasbord                                            //
// Capacitive Liquid Level Sensing (7): Reference Sensor (1) https://youtu.be/XDtQKoT6Zyo //
// -------------------------------------------------------------------------------------- //

//#define DEBUG  // Kommentiere diese Zeile aus, um Debug-Ausgaben zu aktivieren

// Pin-Zuweisungen für die Signal- und Referenzsensoren
const byte sig_sense_pin = 21;    // Pin zur Messung der Signal-Kapazität
const byte sig_drive_pin = 20;    // Pin zum Ansteuern des Signal-Sensors
const unsigned long sig_charge_us = 100;  // Ladezeit für den Signal-Sensor in Mikrosekunden (µs)
const float sig_resistor_mohm = 2.0;  // Widerstandswert des Signal-Sensors in Megaohm (MOhm)
const unsigned long sig_discharge_ms = 10;  // Entladezeit für den Signal-Sensor in Millisekunden (ms)

const byte ref_sense_pin = 18;   // Pin zur Messung der Referenz-Kapazität
const byte ref_drive_pin = 17;   // Pin zum Ansteuern des Referenz-Sensors
const unsigned long ref_charge_us = 150;  // Ladezeit für den Referenz-Sensor in Mikrosekunden (µs)
const float ref_resistor_mohm = 2.0;  // Widerstandswert des Referenz-Sensors in Megaohm (MOhm)
const unsigned long ref_discharge_ms = 10;  // Entladezeit für den Referenz-Sensor in Millisekunden (ms)

const unsigned int average_n_measurements = 20;  // Anzahl der Messungen zum Mittelwert-Bilden für bessere Genauigkeit

// Umrechnungsfaktoren (optional für weitere Berechnungen, aktuell auskommentiert)
// const float conversion_factor = 11.5;  // Faktor zur Umrechnung von Kapazität in Volumen (pF zu ml)
// const float conversion_offset = -569.0; // Offset für die Volumen-Umrechnung (ml)

// Setup-Funktion zum Initialisieren der Pins und der seriellen Kommunikation
void setup()
{
   Serial.begin(1000000L); // Setze die Baudrate für die serielle Kommunikation auf 1MBaud
   while (!Serial);  // Warte, bis die serielle Kommunikation beginnt

   // Initialisiere den Signal-Sensor-Steuerpin als Ausgang
   pinMode(sig_drive_pin, OUTPUT);
   digitalWrite(sig_drive_pin, LOW);  // Setze ihn zunächst auf LOW
   delay(sig_discharge_ms);  // Warte die Entladezeit ab

   // Initialisiere den Referenz-Sensor-Steuerpin als Ausgang
   pinMode(ref_drive_pin, OUTPUT);
   digitalWrite(ref_drive_pin, LOW);  // Setze ihn zunächst auf LOW
   delay(ref_discharge_ms);  // Warte die Entladezeit ab
}

// Hauptloop, der die Kapazität beider Sensoren (Referenz und Signal) misst
void loop()
{
   float ref_capacitance_pf = 0;  // Initialisiere den Wert der Referenz-Kapazität (in pF)
   float sig_capacitance_pf = 0;  // Initialisiere den Wert der Signal-Kapazität (in pF)
   unsigned int measurement;  // Variable zur Speicherung der aktuellen Messung

   // Nimm mehrere Messungen und bilde den Mittelwert
   for (measurement = 0; measurement < average_n_measurements; measurement++)
   {
      // Messe die Kapazität für den Referenz- und den Signal-Sensor
      ref_capacitance_pf += measure_capacitance_pf(ref_sense_pin,
                                                   ref_drive_pin,
                                                   ref_charge_us,
                                                   ref_resistor_mohm,
                                                   ref_discharge_ms);
      sig_capacitance_pf += measure_capacitance_pf(sig_sense_pin,
                                                   sig_drive_pin,
                                                   sig_charge_us,
                                                   sig_resistor_mohm,
                                                   sig_discharge_ms);
   }

   // Berechne den Mittelwert der Kapazitätswerte
   ref_capacitance_pf /= average_n_measurements;
   sig_capacitance_pf /= average_n_measurements;

   // Gebe die Kapazitätswerte in der seriellen Ausgabe aus
   Serial.print(ref_capacitance_pf, 1);  // Gebe die Referenz-Kapazität aus
   Serial.print("pF REF | ");
   Serial.print(sig_capacitance_pf, 1);  // Gebe die Signal-Kapazität aus
   Serial.print("pF SIG | ");
   // Optional kann die Umrechnung der Kapazität in Volumen berechnet und ausgegeben werden (auskommentiert):
   // Serial.print(ref_capacitance_pf * conversion_factor + conversion_offset, 1);
   // Serial.print("ml");

   Serial.println("");  // Gebe eine neue Zeile für die Lesbarkeit aus
   delay(1);  // Kurze Verzögerung vor der nächsten Messung
}

// Funktion zur Messung der Kapazität für einen gegebenen Sensor
float measure_capacitance_pf(byte sense_pin,  // Pin zur Kapazitätsmessung
                             byte drive_pin,  // Pin zum Ansteuern des Sensors
                             unsigned long charge_time_us,  // Ladezeit in Mikrosekunden
                             float resistor_value_mohm,  // Widerstandswert in Megaohm (MOhm)
                             unsigned long discharge_time_ms)  // Entladezeit in Millisekunden
{
   unsigned int adc_value_discharged;  // ADC-Wert im entladenen Zustand
   unsigned int adc_value_charged;     // ADC-Wert im geladenen Zustand

   // Entlade den Sensor, indem der Steuerpin auf LOW gesetzt wird
   digitalWrite(drive_pin, LOW);
   adc_value_discharged = analogRead(sense_pin);  // Lese den ADC-Wert im entladenen Zustand

   // Fehlerbehandlung, wenn die entladene Spannung zu hoch ist
   if (adc_value_discharged > 1023 * 0.01) Serial.println("FEHLER: Entladene Spannung zu hoch!");

   // Lade den Sensor, indem der Steuerpin auf HIGH gesetzt wird
   digitalWrite(drive_pin, HIGH);
   delayMicroseconds(charge_time_us);  // Warte die Ladezeit ab

   adc_value_charged = analogRead(sense_pin);  // Lese den ADC-Wert im geladenen Zustand

   // Setze den Steuerpin wieder auf LOW
   digitalWrite(drive_pin, LOW);
   delay(discharge_time_ms);  // Warte die Entladezeit ab

   // Fehlerbehandlung, wenn die geladene Spannung außerhalb des erwarteten Bereichs liegt
   if (adc_value_charged > 1023 * 0.9) Serial.println("FEHLER: Geladene Spannung zu hoch!");
   if (adc_value_charged < 1023 * 0.2) Serial.println("FEHLER: Geladene Spannung zu niedrig!");

   // Debugging: Gebe die Sensorwerte (entladen und geladen) aus
   #ifdef DEBUG
      Serial.print(sense_pin);
      Serial.print(" | ");
      Serial.print(adc_value_discharged);
      Serial.print(" | ");
      Serial.print(adc_value_charged);
      Serial.print(" | ");
   #endif

   // Gebe die berechnete Kapazität in pF anhand der RC-Ladekurve zurück
   return capacitance_pf(resistor_value_mohm,
                         5.0,  // Versorgungsspannung (5V)
                         charge_time_us,
                         5.0 * adc_value_charged / 1024.0);  // Spannung über dem Kondensator zum Ladezeitpunkt
}

// Funktion zur Berechnung der Kapazität in pF basierend auf der RC-Schaltung
float capacitance_pf(float r_mohm,  // Widerstand in MOhm
                     float vb_v,    // Versorgungsspannung in Volt
                     float t_us,    // Ladezeit in Mikrosekunden
                     float vc_t_v)  // Spannung zum Ladezeitpunkt in Volt
{
   // Kapazitätsberechnungsformel für eine RC-Schaltung:
   // C = - (t / R) * ln(1 - (Vc(t) / Vb))
   return -1.0 * ((t_us / r_mohm) / log(1 - (vc_t_v / vb_v)));
}

/* Erklärungen

Pin-Setup: sig_sense_pin, sig_drive_pin, ref_sense_pin und ref_drive_pin werden verwendet, um die Kapazität der beiden Sensoren zu messen und zu steuern.
RC-Schaltung: Jeder Sensor hat seine eigenen Parameter für Ladezeit, Entladezeit und Widerstandswert.
Messloop: Der Code misst die Kapazität mehrfach (wie durch average_n_measurements angegeben) und bildet den Mittelwert, um genauere Werte zu erhalten.
Kapazitätsberechnung: Die Funktion measure_capacitance_pf() liest die Kapazität, indem sie den Sensor auflädt und entlädt und die Kapazität mit der RC-Formel berechnet.
Serielle Ausgabe: Die Kapazitäten der Referenz- und Signal-Sensoren werden fortlaufend in der seriellen Konsole angezeigt. */